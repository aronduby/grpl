var Q = require('q'),
	murmurhash = require('murmurhash');

function getPool(){ return module.parent.exports.pool; }

/*
 *	Subscribe and unsubscribe will be provided url endpoints
 *	we only want to store the id's that are at the end of those
 *	this extracts that id off the end
*/ 
function extractRegistrationId(endpoint){
	return endpoint.split('/').pop();
}

/*
 *	Store the subscription id in the database
 *	called from the service worker push manager subscription
*/
exports.subscribe = function(endpoint){
	var d = Q.defer(),
		registration_id = extractRegistrationId(endpoint);

	getPool().getConnection(function(err, db){
		if(err){ d.reject(err); return false; }

		// first check if the registration id already exists and we're just updating
		// normally a replace or insert on duplicate key update would work but these ids are huge (potentially 4k)
		// so no being able to index on the actual registration id field
		// and the hashes could technically collide so no using that
		// so check for the hash, and if there's none insert
		// if there's multiple compare the actual field to the value - do nothing on match, insert if no match
		var hash = murmurhash.v3(registration_id);
		db.query("SELECT hash, registration_id FROM push_subscription WHERE hash=?", [hash], function(err, results){
			if(err){ d.reject(err); db.release(); return false; }

			if(results.length === 0){
				db.query("INSERT INTO push_subscription SET hash = ?, registration_id = ?", [hash, registration_id], function(err, results){
					if(err){ d.reject(err); db.release(); return false; }
					d.resolve(registration_id);
					db.release();
				});
			} else {
				var matched = false;
				// slightly hacky way to do a foreach with the ability to break
				results.every(function(row){
					if(row.registration_id == registration_id){
						matched = true;
						return false;
					}
				});

				if(matched){
					d.resolve(registration_id);
					db.release();
				} else {
					db.query("INSERT INTO push_subscription SET hash = ?, registration_id = ?", [hash, registration_id], function(err, results){
						if(err){ d.reject(err); db.release(); return false; }
						d.resolve(registration_id);
						db.release();
					});
				}
			}
		});
	});

	return d.promise;
}

/*
 *	Remove the subscription id from the database
 *	called from the service worker push manager subscription
*/
exports.unsubscribe = function(endpoint){
	var d = Q.defer(),
		registration_id = extractRegistrationId(endpoint);

	getPool().getConnection(function(err, db){
		if(err){ d.reject(err); return false; }

		// see the huge note from subscribe
		var hash = murmurhash.v3(registration_id);
		db.query("SELECT id, hash, registration_id FROM push_subscription WHERE hash = ?", [hash], function(err, results){
			if(err){ d.reject(err); db.release(); return false; }

			if(results.length == 0){
				// nothing stored in db(?), just resolve
				d.resolve(registration_id);
				db.release();
			} else {
				var id = false;
				results.every(function(row){
					if(row.registration_id == registration_id){
						id = row.id;
						return false;
					}
				});

				db.query("DELETE FROM push_subscription WHERE id = ?", [id], function(err, results){
					if(err){ d.reject(err); db.release(); return false; }
					d.resolve(registration_id);
					db.release();
				});
			}
		});
	});

	return d.promise;
}


exports.update = function(old_id, new_id){}
exports.delete = function(id){}