var Q = require('q'),
	redis = require('redis'),
	client = redis.createClient();

// socket.io redis store keeps everything in database 0
// switch this over to database 1 so that we can flush as needed
// without screwing with socket or messing up data entry
client.select(1);

/*
 *	Property GETTERS, pull everything from Redis since it's going to be clustered
*/
exports.started = function(){
	var d = Q.defer();
	client.get('started', function(err, data){
		if(err){ d.resolve(false); return false; }
		d.resolve(data=="1");
	});
	return d.promise;
}

exports.starts = function(){
	var d = Q.defer();
	client.get('starts', function(err, data){
		if(err){ d.reject(err); return false; }
		d.resolve(data);
	});
	return d.promise;
}




/*
 *	 PUBLIC FUNCTIONS
*/
exports.start = function(season_id, starts){
	var d = Q.defer();

	// check if we're already started
	this.started()
	.then(function(started){
		if(started == true){
			exports.resolveWithData(d);
		} else {

			// make sure we don't have any ties
			module.parent.exports.playerlist.getTies(season_id, starts)
			.then(function(ties){

				if(ties.length > 0){
					d.reject({msg: 'You must resolve all the ties before you can start scoring'});
					return false;
				}

				var resolveWith = {
					'started': true,
					'starts': starts,
					'players': [],
					'machines': []
				};

				// populate redis player order using a sorted set
				// populate redis machine info with a hash
				Q.all([
					module.parent.exports.playerlist.getPointsForNight(season_id, starts),
					module.parent.exports.machine.getForLeagueNight(starts)
				])
				.spread(function(player_list, machines){

					resolveWith.players = player_list.players;
					resolveWith.machines = machines;

					// add our machine data and order
					machines.forEach(function(machine){
						client.rpush('machineorder', machine.abbv);
						client.hmset('machine:'+machine.abbv, machine);
					});

					var i = 0,
						past_score = 0;

					player_list.players.forEach(function(player){

						// for proper ordering we have to subtract a tiny number from alike scores
						if(past_score == player.score)
							i = Number(i) - .01;
						else
							i=0;

						past_score = player.score;
						player.score += i;

						// setup the player order and the scores for the player
						client.zadd('playerorder', player.score, player.name_key);
						client.hmset('player:'+player.name_key, player);
						client.hmset('player:'+player.name_key+':scores', player.machines);

					});

					client.set('starts', starts);
					client.set('started', '1');
					d.resolve(resolveWith);
				})
				.fail(function(err){ d.reject(err); })
				.done();

			})
			.fail(function(err){
				d.reject(err);
			}).done();

		}
	}).fail(function(err){ 
		d.reject(err); 
	});

	return d.promise;
}

exports.stop = function(){
	var d = Q.defer();

	client.set('started', '0');

	client.get('starts', function(err, starts){
		if(err){ d.reject(err); return false; }

		// get the values from redis and insert into mysql
		// name keys are stored in the order set
		client.zrange('playerorder', 0, -1, function(err, rsp){
			if(err){ d.reject(err); return false; }

			// now loop through the order and get that hash
			rsp.forEach(function(name_key){
				client.hgetall('player:'+name_key+':scores', function(err, hash){
					if(err){ d.reject(err); return false; }

					var sql = "REPLACE INTO league_night_score (starts, name_key, abbv, points) VALUES (?, ?, ?, ?)";
					getPool().getConnection(function(err, db){
						if(err){ d.reject(err); return false; }

						for(var abbv in hash){
							var score = hash[abbv];

							if(!score)
								continue;

							var query = db.query(sql, [starts, name_key, abbv, score]);
							console.log(query.sql);
						}

						db.release();
					});

				});
			});

			client.flushdb();
			d.resolve(true);
		});

	});

	return d.promise;
}

exports.update = function(data){
	var d = Q.defer(),
		multi = client.multi();

	for(var name_key in data.players){
		multi.hmset('player:'+name_key+':scores', data.abbv, data.players[name_key]);
		// multi.hincrby('player:'+name_key, 'night_score', data.players[name_key]);
	}

	multi.exec(function(err, results){
		if(err){ d.reject(err); return false;}
		d.resolve(data);
	});

	return d.promise;
}

exports.getMachines = function(){
	var d = Q.defer(),
		d2 = Q.defer(),
		multi = client.multi();

	client.lrange('machineorder', 0, -1, function(err, machines){
		if(err){ d.reject(err); return false; }
		machines.forEach(function(abbv){
			multi.hgetall('machine:'+abbv);
		});
		d2.resolve();
	});

	d2.promise.then(function(){
		multi.exec(function(err, results){
			if(err){ d.reject(err); return false;}

			d.resolve(results);
		});
	});

	return d.promise;
}

exports.getPlayers = function(){
	var d = Q.defer(),
		players = [];

	var multi = client.multi();
	client.zrevrange('playerorder', 0, -1, function(err, name_keys){
		if(err){ throw new Error(err) }
		
		name_keys.forEach(function(name_key){
			multi.hgetall('player:'+name_key);
			multi.hgetall('player:'+name_key+':scores');
		});

		multi.exec(function(err, results){
			if(err){ d.reject(err); return false;}

			// results of the calls will come back stacked
			// 0 => player 	1 => player[0] scores
			// 2 => player 	3 => player[2] scores
			// etc.
			var i = 0;
			while(i < results.length){				
				var player = results[i];
				i++;
				player.machines = results[i];

				var night_score = 0;
				for(var abbv in player.machines){
					night_score += Number(player.machines[abbv]);
				}
				player.night_score = night_score;


				players.push(player);
				i++;
			}

			d.resolve(players);
		});
	});

	return d.promise;
}

// resolves the supplied defered object with our data
exports.resolveWithData = function(d){
	var started = exports.started(),
		starts = exports.starts(),
		players = exports.getPlayers(),
		machines = exports.getMachines();

	Q.all([ started, starts, players, machines ])
	.spread(function(started, starts, players, machines){
		d.resolve({
			'started': started,
			'starts': starts,
			'players': players,
			'machines': machines
		});
	}).fail(function(err){
		d.reject(err);
	}).done();

	return d.promise;
}

exports.getGroupForUser = function(name_key){
	var d = Q.defer(),
		promises = [],
		group = {
			order: null,
			players: [],
			machines: []
		};

	Q.all([ 
		Q.ninvoke(client, 'zrevrank', 'playerorder', name_key),
		exports.getMachines()
	]).spread(function(rank, machines){

		var begin = rank - (rank % 4),
			end = begin + 3,
			order = begin / 4,
			offset = order % machines.length;

		// groups 6 and over (index 5) plays behind every other group
		// so 6 follow 1, 7 follows 3, 8 follows 5
		// keeping in mind order is 0 based
		if(order >= 5){
			offset = offset * 2;
		}

		group.order = order;
		group.machines = machines.slice(offset).concat(machines.slice(0,offset));

		client.zrevrange('playerorder', begin, end, function(err, name_keys){
			if(err){ d.reject(err); return false; }

			name_keys.forEach(function(name_key){
				group.players.push({'name_key': name_key, machines: null });
				promises.push( Q.ninvoke(client, 'hgetall', 'player:'+name_key+':scores') );
			});
			Q.all(promises)
			.spread(function(){
				for(var i in arguments){
					group.players[i].machines = arguments[i];
				}
				d.resolve(group);
			})
			.fail(function(err){
				d.reject(err);				
			}).done();
		});

	})
	.fail(function(err){
		d.reject(err);
	}).done();

	return d.promise;
}

exports.tiebreaker = function(data){
	var d = Q.defer(),
		starts = (data.starts == '' ? null : data.starts),
		values = [];

	getPool().getConnection(function(err, db){
		if(err){ d.reject(err); return false; }

		// WHAT HAPPENS IF STARTS IS NULL???

		var sql = "INSERT INTO tie_breaker (starts, name_key, place) VALUES (?, ?, ?) ON DUPLICATE KEY update place=VALUES(place)";
		data.players.forEach(function(p){
			var query = db.query(sql, [starts, p.name_key, p.place]);
			// console.log(query.sql);
		});
		d.resolve(data.players[0].name_key);

		db.release();
	});
	
	return d.promise;
}


/*
 *	Get's the mysql pool connection
*/
function getPool(){
	return module.parent.exports.pool;
}