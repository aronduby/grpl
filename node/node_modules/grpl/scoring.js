var Q = require('q'),
	redis = require('redis'),
	client = redis.createClient();

/*
 *	Property GETTERS, pull everything from Redis since it's going to be clustered
*/
exports.started = function(){
	var d = Q.defer();
	client.get('started', function(err, data){
		if(err){ d.reject(err); return false; }
		d.resolve(data=="1");
	});
	return d.promise;
}

exports.starts = function(){
	var d = Q.defer();
	client.get('starts', function(err, data){
		if(err){ d.reject(err); return false; }
		d.resolve(data);
	});
	return d.promise;
}




/*
 *	 PUBLIC FUNCTIONS
*/
exports.start = function(starts){
	var d = Q.defer();

	// check if we're already started
	this.started()
	.then(function(started){
		if(started == true){
			d.resolve(true);
		} else {
			// populate redis player order using a sorted set
			// populate redis machine info with a hash
			Q.all([
				module.parent.exports.playerlist.getPointsForNight(starts),
				module.parent.exports.machine.getForLeagueNight(starts)
			])
			.spread(function(player_list, machines){

				// add our machine data and order
				machines.forEach(function(machine){
					client.rpush('machineorder', machine.abbv);
					client.hmset('machine:'+machine.abbv, machine);
				});

				var i = 0,
					past_score = 0;

				player_list.players.forEach(function(player){

					// for proper ordering we have to subtract a tiny number from alike scores
					if(past_score == player.score)
						i = Number(i) - .01;
					else
						i=0;

					past_score = player.score;
					player.score += i;

					// setup the player order and the scores for the player
					client.zadd('playerorder', player.score, player.name_key);
					client.hmset('player:'+player.name_key, player.machines);

				});

				client.set('starts', starts);
				client.set('started', '1');
				d.resolve(true);
			})
			.fail(function(err){ d.reject(err); })
			.done();

		}
	}).fail(function(err){ d.reject(err); });

	return d.promise;
}

exports.stop = function(){
	var d = Q.defer();

	client.set('started', '0');

	client.get('starts', function(err, starts){
		if(err){ d.reject(err); return false; }

		// get the values from redis and insert into mysql
		// name keys are stored in the order set
		client.zrange('order', 0, -1, function(err, rsp){
			if(err){ d.reject(err); return false; }

			// now loop through the order and get that hash
			rsp.forEach(function(name_key){
				client.hgetall(name_key, function(err, hash){
					if(err){ d.reject(err); return false; }

					var sql = "REPLACE INTO league_night_score (starts, name_key, abbv, points) VALUES (?, ?, ?, ?)";
					getPool().getConnection(function(err, db){
						if(err){ d.reject(err); return false; }

						for(var abbv in hash){
							var score = hash[abbv];

							db.query(sql, [starts, name_key, abbv, score]);
						}

						db.end();
					});

				});
			});

			client.flushdb();
			d.resolve(true);
		});

	});

	return d.promise;
}

exports.update = function(data){
	var d = Q.defer(),
		all = [];

	for(var name_key in data.players){
		all.push( Q.nfcall( client.hmset, 'player:'+name_key, data.abbv, data.players[name_key]) );
	}
	Q.all(all)
	.then(function(){
		d.resolve();
	})
	.fail(function(err){
		d.reject(err);
	}).done();

	return d.promise;
}

exports.getGroupForUser = function(name_key){
	var d = Q.defer(),
		promises = [],
		group = {
			order: null,
			players: []
		};

	client.zrevrank('playerorder', name_key, function(err, rank){
		if(err){ d.reject(err); return false; }

		var begin = rank - (rank % 4),
			end = begin + 3;

		group.order = begin / 4;
		client.zrevrange('playerorder', begin, end, function(err, name_keys){
			if(err){ d.reject(err); return false; }

			name_keys.forEach(function(name_key){
				group.players.push({'name_key': name_key, machines: null });
				promises.push( Q.ninvoke(client, 'hgetall', 'player:'+name_key) );
			});
			Q.all(promises)
			.spread(function(){
				for(var i in arguments){
					group.players[i].machines = arguments[i];
				}
				d.resolve(group);
			})
			.fail(function(err){
				d.reject(err);				
			}).done();
		});
	})

	return d.promise;
}


/*
 *	Get's the mysql pool connection
*/
function getPool(){
	return module.parent.exports.pool;
}